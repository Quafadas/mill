package build.main
// imports
import mill._
import mill.scalalib._
import mill.contrib.buildinfo.BuildInfo
import mill.T
import mill.define.Cross
import mill.scalalib.api.ZincWorkerUtil
import mill.scalanativelib._

object `package` extends RootModule with build.MillStableScalaModule with BuildInfo {

  def moduleDeps = Seq(eval, resolve, client.jvm)
  def ivyDeps = Agg(
    build.Deps.windowsAnsi,
    build.Deps.coursierInterface,
    build.Deps.mainargs,
    build.Deps.requests,
    build.Deps.logback,
    build.Deps.jgraphtCore,
    ivy"guru.nidi:graphviz-java-min-deps:0.18.1"
  )

  def compileIvyDeps = Task {
    if (ZincWorkerUtil.isScala3(scalaVersion())) Agg.empty
    else Agg(build.Deps.scalaReflect(scalaVersion()))
  }

  def buildInfoPackageName = "mill.main"

  def buildInfoMembers = Seq(
    BuildInfo.Value("scalaVersion", scalaVersion(), "Scala version used to compile mill core."),
    BuildInfo.Value(
      "workerScalaVersion213",
      build.Deps.scala2Version,
      "Scala 2.13 version used by some workers."
    ),
    BuildInfo.Value(
      "workerScalaVersion212",
      build.Deps.workerScalaVersion212,
      "Scala 2.12 version used by some workers."
    ),
    BuildInfo.Value("millVersion", build.millVersion(), "Mill version."),
    BuildInfo.Value("millBinPlatform", build.millBinPlatform(), "Mill binary platform version."),
    BuildInfo.Value(
      "millEmbeddedDeps",
      (
        Task.traverse(
          build.dist.recursiveModuleDeps.collect { case m: PublishModule => m }
        )(
          _.publishSelfDependency
        )()
          .map(artifact => s"${artifact.group}:${artifact.id}:${artifact.version}") ++
          // change to this when bumping Mill:
          //   Lib.resolveDependenciesMetadataSafe(
          Lib.resolveDependenciesMetadata(
            repositories = build.dist.repositoriesTask(),
            // When re-bootstraping Mill, replace the next line with
            //   Seq(BoundDep(build.dist.coursierDependency(), force = false)),
            build.dist.transitiveIvyDeps(),
            Some(build.dist.mapDependencies()),
            build.dist.resolutionCustomizer(),
            Some(Task.ctx()),
            build.dist.coursierCacheCustomizer()
          )._2.minDependencies.toSeq
            // change to this when bumping Mill
            //   ).getOrThrow.minDependencies.toSeq
            .map(d => s"${d.module.organization.value}:${d.module.name.value}:${d.version}")
      )
        //      Task.traverse(dev.moduleDeps)(_.publishSelfDependency)()
        //        .map(artifact => s"${artifact.group}:${artifact.id}:${artifact.version}")
        .mkString(","),
      "Dependency artifacts embedded in mill assembly by default."
    ),
    BuildInfo.Value(
      "millScalacPluginDeps",
      build.Deps.millModuledefsString,
      "Scalac compiler plugin dependencies to compile the build script."
    )
  )

  object api extends build.MillStableScalaModule with BuildInfo {
    def moduleDeps = Seq(client.jvm)
    def buildInfoPackageName = "mill.api"
    def buildInfoMembers = Seq(
      BuildInfo.Value("millVersion", build.millVersion(), "Mill version."),
      BuildInfo.Value("millDocUrl", build.Settings.docUrl, "Mill documentation url."),
      BuildInfo.Value(
        "millReportNewIssueUrl",
        build.Settings.newIssueUrl,
        "URL to create a new issue in Mills issue tracker."
      )
    )

    def ivyDeps = Agg(
      build.Deps.osLib,
      build.Deps.mainargs,
      build.Deps.upickle,
      build.Deps.pprint,
      build.Deps.fansi,
      build.Deps.sbtTestInterface
    )
  }

  object util extends build.MillStableScalaModule {
    def moduleDeps = Seq(api, client.jvm)
    def ivyDeps = Agg(
      build.Deps.coursier,
      build.Deps.coursierJvm,
      build.Deps.jline
    )
  }

  object define extends build.MillStableScalaModule {
    def moduleDeps = Seq(api, util)
    def compileIvyDeps = Task {
      if (ZincWorkerUtil.isScala3(scalaVersion())) Agg(build.Deps.scalaCompiler(scalaVersion()))
      else Agg(build.Deps.scalaReflect(scalaVersion()))
    }
    def ivyDeps = Agg(
      build.Deps.millModuledefs,
      // TODO: somewhere sourcecode is included transitively,
      // but we need the latest version to bring the macro improvements.
      build.Deps.sourcecode,
      // Necessary so we can share the JNA classes throughout the build process
      build.Deps.jna,
      build.Deps.jnaPlatform,
      build.Deps.jarjarabrams,
      build.Deps.mainargs,
      build.Deps.scalaparse
    )
  }

  object eval extends build.MillStableScalaModule {
    def moduleDeps = Seq(define)
  }

  object resolve extends build.MillStableScalaModule {
    def moduleDeps = Seq(define)
  }


  object client extends Module {

    // def scalaVersion = build.Deps.scalaVersion
    trait SharedTests extends SharedClient {
      def ivyDeps = Agg(
        ivy"com.lihaoyi::utest:0.8.5",
        ivy"com.lihaoyi::os-lib::0.11.3"
      )

      override def sources = T.sources {
        Seq(millSourcePath / os.up / "test" ).map(PathRef(_)) ++
         super.sources()
      }
    }

    trait SharedClient extends ScalaModule {
      def scalaVersion = build.Deps.scalaVersion
      // def buildInfoPackageName = "mill.main.client"
      // def buildInfoMembers = T {
      //   Seq(BuildInfo.Value("millVersion", build.millVersion(), "Mill version."))
      // }
      override def sources = T.sources {
        Seq(millSourcePath / os.up / "src" ).map(PathRef(_)) ++
         super.sources()
      }
    }
    object jvm extends build.MillPublishScalaModule with SharedClient with BuildInfo {
      def scalaVersion = build.Deps.scalaVersion

      def buildInfoPackageName = "mill.main.client"
      def buildInfoMembers = T {
        Seq(BuildInfo.Value("millVersion", build.millVersion(), "Mill version."))
      }

      // override lazy val test = new MillScalaTests with SharedTests { // This works
      object test2 extends MillScalaTests with SharedTests { // This works
        def scalaVersion = build.Deps.scalaVersion
        def testFramework = "utest.runner.Framework"
        override def sources = T.sources {
          Seq(millSourcePath / os.up / os.up / "test" ).map(PathRef(_)) ++
          super.sources()
        }
        override def resources = T.sources {
          Seq(millSourcePath / os.up / os.up / "test" / "resources" ).map(PathRef(_)) ++
          super.resources()
        }
      }

    }
    /**
     *
     */
    // object native extends build.MillPublishScalaModule with SharedClient with ScalaNativeModule  {
    //   def scalaVersion = build.Deps.scalaVersion
    //   def scalaNativeVersion = "0.5.6"
    //     override def ivyDeps: T[Agg[Dep]] = super.ivyDeps() ++ Agg(
    //       ivy"pt.kcry::sha::2.0.2"
    //     )
    //   // Will fail until SN 0.5.7
    //   // object test extends ScalaNativeTests {

    //   //   def testFramework = "utest.runner.Framework"

    //   //   def ivyDeps = Agg(
    //   //     ivy"com.lihaoyi::utest::0.8.5"
    //   //   )

    //   //   def nativeEmbedResources = true
    //   // }
    // }

  }


  object server extends build.MillPublishScalaModule {
    def moduleDeps = Seq(client.jvm, api)
  }
  object graphviz extends build.MillPublishScalaModule {
    def moduleDeps = Seq(build.main, build.scalalib)
    def ivyDeps = Agg(build.Deps.jgraphtCore) ++ build.Deps.graphvizJava ++ build.Deps.javet
  }

  def testModuleDeps = super.testModuleDeps ++ Seq(build.testkit)
}
